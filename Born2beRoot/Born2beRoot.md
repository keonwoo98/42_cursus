# **Born2beRoot**

>본 Subject를 진행하기 위한 리눅스 개념 잡기

&nbsp;

## **1. SELinux & AppArmor**

**SELinux**

* Security-Enhanced Linux
* 미국 국방부 스타일의 강제 접근 제어(MAC)를 포함한 접근 제어 보안 정책을 지원하는 매커니즘을 제공하는 리눅스 커널 보안 모듈
* 다양한 리눅스 배포판에 추가할 수 있는 커널 수정 및 사용자 공간 도구들의 모임
* 레드햇 계열 (RHEL, Fedora, CentOS)
* MAC 적용 (전통적인 Linux는 DAC)
* 시스템 전체에 보안 설정

**AppArmor**

* Application Armor
* 시스템 관리자가 프로그램 프로필 별로 프로그램의 역량을 제한할 수 있게 해주는 리눅스 커널 보안 모듈
* SUSE 계열 (SUSE Linux), 데비안 계열 (Debian, Ubuntu)
* MAC 적용 (전통적인 Linux는 DAC)
* 개별 응용 프로그램을 보호하는 일에 집중
* 응용 프로그램 단위의 보안 모델 구현
* AppArmor는 SELinux를 대체하는 한 부분으로서 제공

**둘의 차이점**

* 파일에 라벨을 적용하는 것에 기반하는 SELinux와는 달리, AppArmor는 파일 경로를 통해 작동
* 비슷한 접근법을 취하긴 하지만 SELinux는 경로 대신 아이노드 번호로 파일 시스템 객체들을 구별  
*ex) 하드 링크가 생성됐을 때 아이노드에 참조되는 데이터가 같을 것이기 때문에 SELinux가 계속 새로 생성된 하드 링크에 대한 접근을 거부하는 것과 달리 AppArmor에서는 접근 가능*

&nbsp;

> **보안 모델 :**  
> * DAC (임의 접근 제어, Discretionary Access Control)
>   * 소유자가 사용자 또는 그룹이 자원에 접근하는 것을 조절 (소유자 자유재량)
>   * 주체(소유자)가 객체(파일)를 제어
>   * 계정과 소유권에만 기반
> * MAC (강제 접근 제어, Mandatory Access Control)
>   * 정의된 정책을 활용해 사용자와 프로세스의 행동 제어
>   * 파일의 유형, 사용자의 역할, 프로그램의 기능과 신뢰도, 데이터의 민감성과 무결성 고려

&nbsp;

## **2. apt & aptitude**

우분투에서 패키지를 관리하는 툴에는 `apt`, `dpkg`, `aptitude`가 있다.

* **apt**

    `apt`는 온라인 리포지토리에서 패키지를 다운로드받고 설치하는데 사용된다.  
    실질적으로 `apt`는 `dpkg`와 함께 동작한다. 하지만, 필요한 소프트웨어의 검색, 다운로드, 설치, 업그레이드, 검사 등 대부분의 패키지 관리작업을 `apt`단독으로 가능하다.

* **dpkg**

    `dpkg` 는 Cd룸이나 다른 디스크장치에 있는 .deb 파일을 제어하는 경우에 일반적으로 사용되며, `dpkg`명령어는 시스템 소프트웨어에 대한 설정이나 설치 및 정보를 얻는데 사용되는 옵션을 가진다.  
    `apt`보다는 낮은 수준에서 작업이 수행된다. `apt`는 우분투의 소프트웨어를 관리하기 위해 내부적으로 `dpkg`를 이용한다. 보통 `apt`명령 만으로 충분하지만 시스템에 있는 특정 파일이 어떤 패키지에 포함되는지 등의 확인 작업을 수행하기 위해 `dpkg` 명령이 필요한 것이다.

* **aptitude**

    `dpkg`와 `apt`의 경우 제대로 사용하기 위해서는 좀 더 많은 지식을 요구한다. 그에 비하여 `aptitude`의 경우 주요 패키지 작업 과정을 자동화하여 가능한 쉽게 작업할 수 있도록 해주므로 보다 쉽게 할 수 있다.

&nbsp;

## **3. LVM**

리눅스에서 디스크를 효율적으로 관리하고 사용하기 한 방법으로는 `LVM`과 `RAID` 기술이 있다.

`LVM`(Logical Volume Manager)는 리눅스 안에서 하나의 디스크를 여러 파티션으로 분할해서 파일 시스템을 이용해 특정 디렉터리와 연결시켜 사용한다. 파티션을 논리적인 개념인 볼륨으로 나눠서 더 유동적으로 디스크의 용량을 관리할 수도 있다. 볼륨은 기본적으로 단일 파티션에 상주하게 되지만 다수의 파티션을 하나의 볼륨으로 관리할 수도 있다. 그래서 여러개의 파티션을 합치거나 분할하기에 용이하다.

* **파티션**

    디스크는 파티션이라는 논리적인 크기로 분할 / 통합해서 사용한다. 하나의 디스크를 여러 개로 분할하기도 하고 여러 개의 디스크를 하나의 파티션으로 통합하기도 한다.


    파티션은 고정적이고 물리적인 개념이 강하며 한 번 크기를 설정하면 변경하거나 추가하기 힘들고 OS는 각 파티션을 별도의 디스크처럼 인식한다.

* **볼륨**

    파일 시스템으로 포맷된 디스크 상의 저장 영역이라고도 하며 파티션과 비슷한 개념이지만 엄연히 다르다.

    볼륨은 디스크의 단일 파티션에 상주하게 되며 파티션보다 논리적이로 유동적이다. 우리는 하나의 디스크를 여러 개의 파티션으로 나누어 사용한다. 이때 볼륨은 파티션마다 하나씩 존재하기도 하고, 여러 파티션에 하나만 존재할 수도 있다.

**Ex)**

<table>
    <thead>
        <tr>
            <th>물리 디스크</th>
            <th>파티션</th>
            <th>볼륨 1</th>
            <th>볼륨 2</th>
        </tr>
    </thead>
    <tr>
        <td rowspan="2">하드디스크</td>
        <td>파티션 1</td>
        <td>C:드라이브</td>
        <td rowspan="2">LVM(가상)</td>
    </tr>
    <tr>
        <td>파티션 2</td>
        <td>D:드라이브</td>
    </tr>
</table>

> *디스크를 2개의 파티션으로 나누었을 때, 각각의 파티션마다 1개의 볼륨을 가져 총 2개의 볼륨을 가질 수도 있고 2개의 파티션이 1개의 볼륨을 가질 수도 있다.*

&nbsp;

리눅스에서 디스크를 사용하는 가장 기본적인 방법은 디스크를 파티션으로 나누어 각각의 디렉터리에 파일 시스템으로 마운트 한 뒤 지정된 위치에 데이터를 저장해서 사용하는 것이다.  
(디스크 → 파티션 → 볼륨그룹 → 논리그룹 → 파일시스템(/home))

`LVM`을 적용하게 되면 디스크를 변경, 추가할 때 물리적인 부분을 건드릴 필요가 없어 여러 디스크를 하나로 뭉쳐서 사용할 수도 있고 하나의 디스크를 여러 디스크인 것 처럼 나누어 사용할 수도 있다.  
사용 중인 파티션의 크기를 바꿀 수도 있고 디스크를 추가한 뒤 간단한 작업을 통해 용량을 확장시킬 수도 있다.

<table>
    <thead>
        <tr>
            <th>물리 디스크</th>
            <th>물리 디스크</th>
        <tr>
    </thead>
    <tr>
        <td>파티션</td>
        <td>파티션</td>
    </tr>
    <tr>
        <td>물리 볼륨</td>
        <td>물리 볼륨</td>
    </tr>
    <tr>
        <td rowspan="3">파일 시스템</td>
        <td>논리 그룹 (LVM)</td>
    </tr>
    <tr>
        <td>논리 그룹 (LVM)</td>
    </tr>
    <tr>
        <td>파일 시스템</td>
    </tr>
</table>

&nbsp;

디스크를 좀 더 유연하게 사용하기 위해 물리적인 파티션을 논리적인 볼륨으로 바꿔서 사용한다. `LVM`에서는 여러 파티션을 하나의 논리적인 볼륨으로 묶은 뒤 다시 필요한 크기만큼 나눠서 사용할 수 있다.

**`LVM`의 구성 :**

* **PV(Physical Volume)**

    * 물리적 볼륨으로 디스크를 `LVM`에서 사용할 수 있게 변환하는 작업
    * 디스크의 파티션을 `PV`로 초기화시켜 일정한 크기의 `PE`로 구성

* **VG(Volume Group)**

    * `PV`가 모여 만들어진 그룹
    * 물리적인 일정한 크기의 `PE`로 구성된 `PV`들이 모여 `VG`가 만들어짐
    * `VG`는 다시 `LV`로 할당할 수 있는 공간을 말하기도 함

* **PE(Physical Extent)**

    * `PV`에서 나누어 사용하는 블록
    * 보통 `1PE`의 크기는 4MB이며 `VG`가 새롭게 나누는 논리적인 `LV`의 `LE`와 1:1 대응

* **LV(Logical Volume)**

    * `VG`에서 사용자가 필요한 만큼 할당되서 만들어지는 공간
    * 논리적인 파티션이라고 볼 수 있으며 이는 다시 `LE`로 나누어짐

* **LE(Logical Extent)**

    * `LV`가 나누어진 일정한 크기의 블록으로 물리적 크기인 `PE`와 1:1 대응

<table>
    <tr>
        <td colspan="4" style="text-align: center">물리 디스크</td>
    </tr>
    <tr>
        <td colspan="2">파티션1</td>
        <td colspan="2">파티션2</td>
    </tr>
    <tr>
        <td colspan="2">PV (물리적 볼륨)</td>
        <td colspan="2">PV (물리적 볼륨)</td>
    </tr>
    <tr>
        <td>PE (4MB)</td>
        <td>PE (4MB)</td>
        <td>PE (4MB)</td>
        <td>PE (4MB)</td>
    </tr>
    <tr>
        <td colspan="4" style="text-align: center">VG (볼륨 그룹)</td>
    </tr>
    <tr>
        <td colspan="2">LV (논리적 볼륨)</td>
        <td colspan="2">LV (논리적 볼륨)</td>
    </tr>
    <tr>
        <td>LE (4MB)</td>
        <td>LE (4MB)</td>
        <td>LE (4MB)</td>
        <td>LE (4MB)</td>
    </tr>
</table>

&nbsp;

물리적인 크기를 논리적인 크기로 바꿔서 분할, 결합이 더 유연하다.  
물리적 크기인 `PE`는 논리적 크기인 `LE`와 1:1 맵핑하게 된다.

&nbsp;


>참고 사이트 :
> * https://ko.wikipedia.org/wiki/AppArmor#cite_note-2
> * https://2infinity.tistory.com/59
> * http://tpholic.com/xe/5102649
> * https://wiseworld.tistory.com/32